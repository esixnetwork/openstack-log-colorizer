#!/usr/bin/env python

import sys
import re
import argparse

PARSER = argparse.ArgumentParser()
PARSER.add_argument("-l", "--level",
            help="Set log level you want display",
            metavar='level',
            type=str)
PARSER.add_argument("-e", "--exclude",
            help="Set log level you want exclude",
            metavar='level',
            type=str,
            nargs='+')
PARSER.add_argument("-i", "--include",
            help="Set log level you only want display",
            metavar='level',
            type=str,
            nargs='+')
ARGS = PARSER.parse_args()

LOG_LEVEL = {
    'critical': 50,
    'error': 40,
    'warning': 30,
    'info': 20,
    'debug': 10,
    'notset': 100,
}

class colors:
    grey = '\033[1;30m'
    red =  '\033[1;31m'
    green = '\033[1;32m'
    yellow = '\033[1;33m'
    blue = '\033[1;34m'
    magenta = '\033[1;35m'
    cyan = '\033[1;36m'
    white = '\033[0;37m'
    end = '\033[1;m'

def grey(text):
    return '%s%s%s' % (colors.grey, text, colors.end)

def red(text):
    return '%s%s%s' % (colors.red, text, colors.end)

def green(text):
    return '%s%s%s' % (colors.green, text, colors.end)

def yellow(text):
    return '%s%s%s' % (colors.yellow, text, colors.end)

def blue(text):
    return '%s%s%s' % (colors.blue, text, colors.end)

def magenta(text):
    return '%s%s%s' % (colors.magenta, text, colors.end)

def cyan(text):
    return '%s%s%s' % (colors.cyan, text, colors.end)

def white(text):
    return '%s%s%s' % (colors.white, text, colors.end)

def parse_line(line):
    "Parse line and return dict of each elements"
    # Line example :
    # 2014-08-14 18:43:58.950 4092 INFO neutron.plugins.openvswitch.agent.ovs_neutron_agent
    regex = (r'^([0-9]+-[0-9]+-[0-9]+) ' # date
             '([0-9]+:[0-9]+:[0-9]+\.[0-9]+) ' # time
             '([0-9]+):? ' # process
             '([A-Z]+) ' # level
             '([^ ]+) ' # name
             '(.+)') # text

    result = re.match(regex, line)
    if result is not None:
        return { 'date': result.group(1),
          'time': result.group(2),
          'process': result.group(3),
          'level': result.group(4),
          'name': result.group(5),
          'text': result.group(6),
        }
    return {'text': line}

def colored_level(level):
    "Return level text with selected color tag"
    if level in ['TRACE']:
        return magenta(level)
    if level in ['DEBUG', 'INFO']:
        return green(level)
    if level in ['WARNING']:
        return yellow(level)
    if level in ['CRITICAL', 'ERROR']:
        return red(level)


def colorize(line):
    "Apply color tag on line"

    # Unparsed line (without level)
    if line.get('level') is None:
        return '%s' % (line.get('text'))

    # parsed line
    if line['level'] == 'TRACE':
        return '%s %s %s %s %s %s' % ( grey(line['date']),
                                   grey(line['time']),
                                   grey(line['process']),
                                   colored_level(line['level']),
                                   blue(line['name']),
                                   grey(line['text']),)
    else:
        return '%s %s %s %s %s %s' % ( grey(line['date']),
                                   grey(line['time']),
                                   grey(line['process']),
                                   colored_level(line['level']),
                                   blue(line['name']),
                                   white(line['text']),)

def check_args():
    # Just allow one arg
    num_args = sum(1 for i in [ARGS.level, ARGS.exclude, ARGS.include] if i)
    if num_args > 1:
        print 'Args conflicts select just one arg'
        PARSER.print_help()
        return False
    return True

def level_filter(line):
    "Return true if line must be filtered. Never filter line without level"
    level = ARGS.level.lower()
    line_level = line.get('level', 'notset').lower()
    if LOG_LEVEL.get(line_level, 100) < LOG_LEVEL.get(level, 0):
        return True
    else:
        return False

def include_filter(line):
    "Return true if line must be filtered. Never filter line without level"
    includes = [i.lower() for i in ARGS.include]
    line_level = line.get('level', 'notset').lower()
    if line_level == 'notset':
        return False
    elif line_level in includes:
        return False
    return True

def exclude_filter(line):
    "Return true if line must be filtered. Never filter line without level"
    excludes = [e.lower() for e in ARGS.exclude]
    line_level = line.get('level', 'notset').lower()
    if line_level in excludes:
        return True
    return False

def line_is_filtered(line):
    "Skip the line ?"

    if ARGS.level:
        return level_filter(line)
    elif ARGS.include:
        return include_filter(line)
    elif ARGS.exclude:
        return exclude_filter(line)
    return False


if __name__ == '__main__':
    # Read each line in stdin
    if not check_args():
        sys.exit(1)

    while 1:
        try:
            line = sys.stdin.readline()
        except KeyboardInterrupt:
            break

        if not line:
            break

        # get parsed line
        parsed_line = parse_line(line.rstrip('\n'))

        # Skip line if filtred (never skip line without log level)
        if line_is_filtered(parsed_line):
            continue

        # Print parsed and colored line
        print colorize(parsed_line)


